\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex}{}\section{software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex Class Reference}
\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex}\index{software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex@{software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_abd7fd7245695b21792563d424b09ac27}{\+\_\+\+\_\+init\+\_\+\+\_\+}
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a775e8d95913df4a5ad79a59e7155f605}{loadhex} (self, fobj)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_acd9716aa6677362786b1d8655b8707fb}{loadbin}
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ad59eb04b61c35a525596bbfbef87329f}{loadfile} (self, fobj, format)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_acaa7238f52227ae07a4aa4e4b1ab0909}{fromdict} (self, dikt)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aa262db6dc7ed1909cf4285783abd6d20}{frombytes}
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a328f8941824c4b535fb8bafbc1dd9add}{tobinarray}
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a63beaff3fa8ff85530da070327451542}{tobinstr}
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a1591d7944d6232ffbe20231e5b3547e0}{tobinfile}
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a7a570a4d3b81de987e2feb5fd1246ed3}{todict} (self)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aabb8244499b70970774dda776e4b1e89}{addresses} (self)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ace69ca817be9cb8f87c5f18751f7a519}{minaddr} (self)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aee2c8b04d227d7fe36ffe916c7b85650}{maxaddr} (self)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ac5c081de76f8ae0239f4edf59450dd55}{\+\_\+\+\_\+getitem\+\_\+\+\_\+} (self, addr)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_abbe9f60e13d163ec0926fa66727015e4}{\+\_\+\+\_\+setitem\+\_\+\+\_\+} (self, addr, byte)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a37b2f67753331c44156e9f7cdd80a0eb}{\+\_\+\+\_\+delitem\+\_\+\+\_\+} (self, addr)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a6b2ca9b10065e8144071ea1b199dda7f}{\+\_\+\+\_\+len\+\_\+\+\_\+} (self)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a8f58a0cbc330f6c0304a291b7ffad1aa}{write\+\_\+hex\+\_\+file}
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a2781d7631635f5ea07af10cd11f25908}{tofile} (self, fobj, format)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a585027d569ec62b83f71a2a554f00045}{gets} (self, addr, length)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_af871cf5e14945bd217996c1cae0c2fa3}{puts} (self, addr, s)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aa93411d4b588b40e57a29dd47c1ab201}{getsz} (self, addr)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a533c4b8136caaf0fdfb0f9588cbf09c2}{putsz} (self, addr, s)
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ae32a6358e1567e9b9dd148d8290c9b57}{dump}
\item 
def \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a8f12aea49042cd61c56c2d650fab5fa2}{merge}
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_af1b0c8c73d204cd8677cf6840511d3b0}{padding}
\item 
\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\+\_\+addr}
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aedb3e9ce405494ffb08bfd4051c9bcc7}{fromfile} = \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ad59eb04b61c35a525596bbfbef87329f}{loadfile}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Intel HEX file reader. \end{DoxyVerb}
 

Inheritance diagram for software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=256pt]{d9/d7f/classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=256pt]{d6/d97/classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex__coll__graph}
\end{center}
\end{figure}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_abd7fd7245695b21792563d424b09ac27}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{\+\_\+\+\_\+init\+\_\+\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+\+\_\+init\+\_\+\+\_\+ (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{source = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_abd7fd7245695b21792563d424b09ac27}
\begin{DoxyVerb}Constructor. If source specified, object will be initialized
with the contents of source. Otherwise the object will be empty.

@param  source      source for initialization
            (file name of HEX file, file object, addr dict or
             other IntelHex object)
\end{DoxyVerb}
 
\begin{DoxyCode}
79     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_abd7fd7245695b21792563d424b09ac27}{\_\_init\_\_}(self, source=None):
80         \textcolor{stringliteral}{''' Constructor. If source specified, object will be initialized}
81 \textcolor{stringliteral}{        with the contents of source. Otherwise the object will be empty.}
82 \textcolor{stringliteral}{}
83 \textcolor{stringliteral}{        @param  source      source for initialization}
84 \textcolor{stringliteral}{                            (file name of HEX file, file object, addr dict or}
85 \textcolor{stringliteral}{                             other IntelHex object)}
86 \textcolor{stringliteral}{        '''}
87         \textcolor{comment}{# public members}
88         self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_af1b0c8c73d204cd8677cf6840511d3b0}{padding} = 0x0FF
89         \textcolor{comment}{# Start Address}
90         self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr} = \textcolor{keywordtype}{None}
91 
92         \textcolor{comment}{# private members}
93         self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf} = \{\}
94         self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ae76fa50a74ef63f6d385854c330203ef}{\_offset} = 0
95 
96         \textcolor{keywordflow}{if} source \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
97             \textcolor{keywordflow}{if} isinstance(source, StrType) \textcolor{keywordflow}{or} getattr(source, \textcolor{stringliteral}{"read"}, \textcolor{keywordtype}{None}):
98                 \textcolor{comment}{# load hex file}
99                 self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a775e8d95913df4a5ad79a59e7155f605}{loadhex}(source)
100             \textcolor{keywordflow}{elif} isinstance(source, dict):
101                 self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_acaa7238f52227ae07a4aa4e4b1ab0909}{fromdict}(source)
102             \textcolor{keywordflow}{elif} isinstance(source, IntelHex):
103                 self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_af1b0c8c73d204cd8677cf6840511d3b0}{padding} = source.padding
104                 \textcolor{keywordflow}{if} source.start\_addr:
105                     self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr} = source.start\_addr.copy()
106                 self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf} = source.\_buf.copy()
107             \textcolor{keywordflow}{else}:
108                 \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"source: bad initializer type"})
109 
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a37b2f67753331c44156e9f7cdd80a0eb}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!\+\_\+\+\_\+delitem\+\_\+\+\_\+@{\+\_\+\+\_\+delitem\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+delitem\+\_\+\+\_\+@{\+\_\+\+\_\+delitem\+\_\+\+\_\+}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{\+\_\+\+\_\+delitem\+\_\+\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+\+\_\+delitem\+\_\+\+\_\+ (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{addr}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a37b2f67753331c44156e9f7cdd80a0eb}
\begin{DoxyVerb}Delete byte at address.\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+dict\+\_\+keys(), and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+range\+\_\+g.


\begin{DoxyCode}
524     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a37b2f67753331c44156e9f7cdd80a0eb}{\_\_delitem\_\_}(self, addr):
525         \textcolor{stringliteral}{"""Delete byte at address."""}
526         t = type(addr)
527         \textcolor{keywordflow}{if} t \textcolor{keywordflow}{in} IntTypes:
528             \textcolor{keywordflow}{if} addr < 0:
529                 \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{'Address should be >= 0.'})
530             del self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf}[addr]
531         \textcolor{keywordflow}{elif} t == slice:
532             addresses = \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a675ad269e4a9a3ee5a5b4b413d0fb690}{dict\_keys}(self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf})
533             \textcolor{keywordflow}{if} addresses:
534                 addresses.sort()
535                 start = addr.start \textcolor{keywordflow}{or} addresses[0]
536                 stop = addr.stop \textcolor{keywordflow}{or} (addresses[-1] + 1)
537                 step = addr.step \textcolor{keywordflow}{or} 1
538                 \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_abac275d54b0c0dc47a6ef2f7c4f7bcdf}{range\_g}(start, stop, step):
539                     x = self.\_buf.get(i)
540                     \textcolor{keywordflow}{if} x \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
541                         del self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf}[i]
542         \textcolor{keywordflow}{else}:
543             \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{'Address has unsupported type: %s'} % t)
544 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ac5c081de76f8ae0239f4edf59450dd55}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!\+\_\+\+\_\+getitem\+\_\+\+\_\+@{\+\_\+\+\_\+getitem\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+getitem\+\_\+\+\_\+@{\+\_\+\+\_\+getitem\+\_\+\+\_\+}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{\+\_\+\+\_\+getitem\+\_\+\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+\+\_\+getitem\+\_\+\+\_\+ (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{addr}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ac5c081de76f8ae0239f4edf59450dd55}
\begin{DoxyVerb}Get requested byte from address.
@param  addr    address of byte.
@return         byte if address exists in HEX file, or self.padding
        if no data found.
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+dict\+\_\+keys(), software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+padding, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+range\+\_\+g.


\begin{DoxyCode}
462     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ac5c081de76f8ae0239f4edf59450dd55}{\_\_getitem\_\_}(self, addr):
463         \textcolor{stringliteral}{''' Get requested byte from address.}
464 \textcolor{stringliteral}{        @param  addr    address of byte.}
465 \textcolor{stringliteral}{        @return         byte if address exists in HEX file, or self.padding}
466 \textcolor{stringliteral}{                        if no data found.}
467 \textcolor{stringliteral}{        '''}
468         t = type(addr)
469         \textcolor{keywordflow}{if} t \textcolor{keywordflow}{in} IntTypes:
470             \textcolor{keywordflow}{if} addr < 0:
471                 \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{'Address should be >= 0.'})
472             \textcolor{keywordflow}{return} self.\_buf.get(addr, self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_af1b0c8c73d204cd8677cf6840511d3b0}{padding})
473         \textcolor{keywordflow}{elif} t == slice:
474             addresses = \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a675ad269e4a9a3ee5a5b4b413d0fb690}{dict\_keys}(self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf})
475             ih = \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex}{IntelHex}()
476             \textcolor{keywordflow}{if} addresses:
477                 addresses.sort()
478                 start = addr.start \textcolor{keywordflow}{or} addresses[0]
479                 stop = addr.stop \textcolor{keywordflow}{or} (addresses[-1] + 1)
480                 step = addr.step \textcolor{keywordflow}{or} 1
481                 \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_abac275d54b0c0dc47a6ef2f7c4f7bcdf}{range\_g}(start, stop, step):
482                     x = self.\_buf.get(i)
483                     \textcolor{keywordflow}{if} x \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
484                         ih[i] = x
485             \textcolor{keywordflow}{return} ih
486         \textcolor{keywordflow}{else}:
487             \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{'Address has unsupported type: %s'} % t)
488 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a6b2ca9b10065e8144071ea1b199dda7f}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!\+\_\+\+\_\+len\+\_\+\+\_\+@{\+\_\+\+\_\+len\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+len\+\_\+\+\_\+@{\+\_\+\+\_\+len\+\_\+\+\_\+}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{\+\_\+\+\_\+len\+\_\+\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+\+\_\+len\+\_\+\+\_\+ (
\begin{DoxyParamCaption}
\item[{}]{self}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a6b2ca9b10065e8144071ea1b199dda7f}
\begin{DoxyVerb}Return count of bytes with real values.\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+dict\+\_\+keys().


\begin{DoxyCode}
545     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a6b2ca9b10065e8144071ea1b199dda7f}{\_\_len\_\_}(self):
546         \textcolor{stringliteral}{"""Return count of bytes with real values."""}
547         \textcolor{keywordflow}{return} len(\hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a675ad269e4a9a3ee5a5b4b413d0fb690}{dict\_keys}(self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf}))
548 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_abbe9f60e13d163ec0926fa66727015e4}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!\+\_\+\+\_\+setitem\+\_\+\+\_\+@{\+\_\+\+\_\+setitem\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+setitem\+\_\+\+\_\+@{\+\_\+\+\_\+setitem\+\_\+\+\_\+}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{\+\_\+\+\_\+setitem\+\_\+\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+\+\_\+setitem\+\_\+\+\_\+ (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{addr, }
\item[{}]{byte}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_abbe9f60e13d163ec0926fa66727015e4}
\begin{DoxyVerb}Set byte at address.\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+range\+\_\+g, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+range\+\_\+l.


\begin{DoxyCode}
489     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_abbe9f60e13d163ec0926fa66727015e4}{\_\_setitem\_\_}(self, addr, byte):
490         \textcolor{stringliteral}{"""Set byte at address."""}
491         t = type(addr)
492         \textcolor{keywordflow}{if} t \textcolor{keywordflow}{in} IntTypes:
493             \textcolor{keywordflow}{if} addr < 0:
494                 \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{'Address should be >= 0.'})
495             self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf}[addr] = byte
496         \textcolor{keywordflow}{elif} t == slice:
497             \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} isinstance(byte, (list, tuple)):
498                 \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{'Slice operation expects sequence of bytes'})
499             start = addr.start
500             stop = addr.stop
501             step = addr.step \textcolor{keywordflow}{or} 1
502             \textcolor{keywordflow}{if} \textcolor{keywordtype}{None} \textcolor{keywordflow}{not} \textcolor{keywordflow}{in} (start, stop):
503                 ra = \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_ae461be5d25f46823cb710380e27eb1a1}{range\_l}(start, stop, step)
504                 \textcolor{keywordflow}{if} len(ra) != len(byte):
505                     \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{'Length of bytes sequence does not match '}
506                         \textcolor{stringliteral}{'address range'})
507             \textcolor{keywordflow}{elif} (start, stop) == (\textcolor{keywordtype}{None}, \textcolor{keywordtype}{None}):
508                 \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{'Unsupported address range'})
509             \textcolor{keywordflow}{elif} start \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:
510                 start = stop - len(byte)
511             \textcolor{keywordflow}{elif} stop \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:
512                 stop = start + len(byte)
513             \textcolor{keywordflow}{if} start < 0:
514                 \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{'start address cannot be negative'})
515             \textcolor{keywordflow}{if} stop < 0:
516                 \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{'stop address cannot be negative'})
517             j = 0
518             \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_abac275d54b0c0dc47a6ef2f7c4f7bcdf}{range\_g}(start, stop, step):
519                 self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf}[i] = byte[j]
520                 j += 1
521         \textcolor{keywordflow}{else}:
522             \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{'Address has unsupported type: %s'} % t)
523 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aabb8244499b70970774dda776e4b1e89}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!addresses@{addresses}}
\index{addresses@{addresses}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{addresses}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+addresses (
\begin{DoxyParamCaption}
\item[{}]{self}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aabb8244499b70970774dda776e4b1e89}
\begin{DoxyVerb}Returns all used addresses in sorted order.
@return         list of occupied data addresses in sorted order. 
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+dict\+\_\+keys().


\begin{DoxyCode}
434     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aabb8244499b70970774dda776e4b1e89}{addresses}(self):
435         \textcolor{stringliteral}{'''Returns all used addresses in sorted order.}
436 \textcolor{stringliteral}{        @return         list of occupied data addresses in sorted order. }
437 \textcolor{stringliteral}{        '''}
438         aa = \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a675ad269e4a9a3ee5a5b4b413d0fb690}{dict\_keys}(self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf})
439         aa.sort()
440         \textcolor{keywordflow}{return} aa
441 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ae32a6358e1567e9b9dd148d8290c9b57}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!dump@{dump}}
\index{dump@{dump}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{dump}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+dump (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{tofile = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ae32a6358e1567e9b9dd148d8290c9b57}
\begin{DoxyVerb}Dump object content to specified file object or to stdout if None.
Format is a hexdump with some header information at the beginning,
addresses on the left, and data on right.

@param  tofile        file-like object to dump to
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+dict\+\_\+keys(), software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+range\+\_\+g, software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+range\+\_\+l, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+start\+\_\+addr.


\begin{DoxyCode}
762     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ae32a6358e1567e9b9dd148d8290c9b57}{dump}(self, tofile=None):
763         \textcolor{stringliteral}{"""Dump object content to specified file object or to stdout if None.}
764 \textcolor{stringliteral}{        Format is a hexdump with some header information at the beginning,}
765 \textcolor{stringliteral}{        addresses on the left, and data on right.}
766 \textcolor{stringliteral}{}
767 \textcolor{stringliteral}{        @param  tofile        file-like object to dump to}
768 \textcolor{stringliteral}{        """}
769 
770         \textcolor{keywordflow}{if} tofile \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:
771             tofile = sys.stdout
772         \textcolor{comment}{# start addr possibly}
773         \textcolor{keywordflow}{if} self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr} \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
774             cs = self.start\_addr.get(\textcolor{stringliteral}{'CS'})
775             ip = self.start\_addr.get(\textcolor{stringliteral}{'IP'})
776             eip = self.start\_addr.get(\textcolor{stringliteral}{'EIP'})
777             \textcolor{keywordflow}{if} eip \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None} \textcolor{keywordflow}{and} cs \textcolor{keywordflow}{is} \textcolor{keywordtype}{None} \textcolor{keywordflow}{and} ip \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:
778                 tofile.write(\textcolor{stringliteral}{'EIP = 0x%08X\(\backslash\)n'} % eip)
779             \textcolor{keywordflow}{elif} eip \textcolor{keywordflow}{is} \textcolor{keywordtype}{None} \textcolor{keywordflow}{and} cs \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None} \textcolor{keywordflow}{and} ip \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
780                 tofile.write(\textcolor{stringliteral}{'CS = 0x%04X, IP = 0x%04X\(\backslash\)n'} % (cs, ip))
781             \textcolor{keywordflow}{else}:
782                 tofile.write(\textcolor{stringliteral}{'start\_addr = %r\(\backslash\)n'} % start\_addr)
783         \textcolor{comment}{# actual data}
784         addresses = \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a675ad269e4a9a3ee5a5b4b413d0fb690}{dict\_keys}(self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf})
785         \textcolor{keywordflow}{if} addresses:
786             addresses.sort()
787             minaddr = addresses[0]
788             maxaddr = addresses[-1]
789             startaddr = int(minaddr >> 4) * 16
790             endaddr = int((maxaddr >> 4) + 1) * 16
791             maxdigits = max(len(str(endaddr)), 4)
792             templa = \textcolor{stringliteral}{'%%0%dX'} % maxdigits
793             range16 = \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_ae461be5d25f46823cb710380e27eb1a1}{range\_l}(16)
794             \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_abac275d54b0c0dc47a6ef2f7c4f7bcdf}{range\_g}(startaddr, endaddr, 16):
795                 tofile.write(templa % i)
796                 tofile.write(\textcolor{stringliteral}{' '})
797                 s = []
798                 \textcolor{keywordflow}{for} j \textcolor{keywordflow}{in} range16:
799                     x = self.\_buf.get(i + j)
800                     \textcolor{keywordflow}{if} x \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
801                         tofile.write(\textcolor{stringliteral}{' %02X'} % x)
802                         \textcolor{keywordflow}{if} 32 <= x < 127:  \textcolor{comment}{# GNU less does not like 0x7F (128 decimal) so we'd better show
       it as dot}
803                             s.append(chr(x))
804                         \textcolor{keywordflow}{else}:
805                             s.append(\textcolor{stringliteral}{'.'})
806                     \textcolor{keywordflow}{else}:
807                         tofile.write(\textcolor{stringliteral}{' --'})
808                         s.append(\textcolor{stringliteral}{' '})
809                 tofile.write(\textcolor{stringliteral}{'  |'} + \textcolor{stringliteral}{''}.join(s) + \textcolor{stringliteral}{'|\(\backslash\)n'})
810 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aa262db6dc7ed1909cf4285783abd6d20}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!frombytes@{frombytes}}
\index{frombytes@{frombytes}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{frombytes}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+frombytes (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{bytes, }
\item[{}]{offset = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aa262db6dc7ed1909cf4285783abd6d20}
\begin{DoxyVerb}Load data from array or list of bytes.
Similar to loadbin() method but works directly with iterable bytes.
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+maxaddr(), and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+minaddr().



Referenced by software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+loadbin().


\begin{DoxyCode}
290     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aa262db6dc7ed1909cf4285783abd6d20}{frombytes}(self, bytes, offset=0):
291         \textcolor{stringliteral}{"""Load data from array or list of bytes.}
292 \textcolor{stringliteral}{        Similar to loadbin() method but works directly with iterable bytes.}
293 \textcolor{stringliteral}{        """}
294         \textcolor{keywordflow}{for} b \textcolor{keywordflow}{in} bytes:
295             self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf}[offset] = b
296             offset += 1
297 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_acaa7238f52227ae07a4aa4e4b1ab0909}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!fromdict@{fromdict}}
\index{fromdict@{fromdict}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{fromdict}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+fromdict (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{dikt}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_acaa7238f52227ae07a4aa4e4b1ab0909}
\begin{DoxyVerb}Load data from dictionary. Dictionary should contain int keys
representing addresses. Values should be the data to be stored in
those addresses in unsigned char form (i.e. not strings).
The dictionary may contain the key, ``start_addr``
to indicate the starting address of the data as described in README.

The contents of the dict will be merged with this object and will
overwrite any conflicts. This function is not necessary if the
object was initialized with source specified.
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+dict\+\_\+keys\+\_\+g(), and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+start\+\_\+addr.


\begin{DoxyCode}
268     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_acaa7238f52227ae07a4aa4e4b1ab0909}{fromdict}(self, dikt):
269         \textcolor{stringliteral}{"""Load data from dictionary. Dictionary should contain int keys}
270 \textcolor{stringliteral}{        representing addresses. Values should be the data to be stored in}
271 \textcolor{stringliteral}{        those addresses in unsigned char form (i.e. not strings).}
272 \textcolor{stringliteral}{        The dictionary may contain the key, ``start\_addr``}
273 \textcolor{stringliteral}{        to indicate the starting address of the data as described in README.}
274 \textcolor{stringliteral}{}
275 \textcolor{stringliteral}{        The contents of the dict will be merged with this object and will}
276 \textcolor{stringliteral}{        overwrite any conflicts. This function is not necessary if the}
277 \textcolor{stringliteral}{        object was initialized with source specified.}
278 \textcolor{stringliteral}{        """}
279         s = dikt.copy()
280         start\_addr = s.get(\textcolor{stringliteral}{'start\_addr'})
281         \textcolor{keywordflow}{if} start\_addr \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
282             del s[\textcolor{stringliteral}{'start\_addr'}]
283         \textcolor{keywordflow}{for} k \textcolor{keywordflow}{in} \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a623edc32a44436e3e93e2792e756bfc8}{dict\_keys\_g}(s):
284             \textcolor{keywordflow}{if} type(k) \textcolor{keywordflow}{not} \textcolor{keywordflow}{in} IntTypes \textcolor{keywordflow}{or} k < 0:
285                 \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{'Source dictionary should have only int keys'})
286         self.\_buf.update(s)
287         \textcolor{keywordflow}{if} start\_addr \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
288             self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr} = start\_addr
289 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a585027d569ec62b83f71a2a554f00045}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!gets@{gets}}
\index{gets@{gets}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{gets}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+gets (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{addr, }
\item[{}]{length}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a585027d569ec62b83f71a2a554f00045}
\begin{DoxyVerb}Get string of bytes from given address. If any entries are blank
from addr through addr+length, a NotEnoughDataError exception will
be raised. Padding is not used.\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+asbytes, software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+asstr, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+range\+\_\+g.



Referenced by software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+getsz().


\begin{DoxyCode}
722     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a585027d569ec62b83f71a2a554f00045}{gets}(self, addr, length):
723         \textcolor{stringliteral}{"""Get string of bytes from given address. If any entries are blank}
724 \textcolor{stringliteral}{        from addr through addr+length, a NotEnoughDataError exception will}
725 \textcolor{stringliteral}{        be raised. Padding is not used."""}
726         a = array(\textcolor{stringliteral}{'B'}, \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a7f086f0677c4876409244a91e386b8cc}{asbytes}(\textcolor{stringliteral}{'\(\backslash\)0'} * length))
727         \textcolor{keywordflow}{try}:
728             \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_abac275d54b0c0dc47a6ef2f7c4f7bcdf}{range\_g}(length):
729                 a[i] = self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf}[addr + i]
730         \textcolor{keywordflow}{except} KeyError:
731             \textcolor{keywordflow}{raise} \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1NotEnoughDataError}{NotEnoughDataError}(address=addr, length=length)
732         \textcolor{keywordflow}{return} \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a32eb6deeafe6dba1f76d94543cff7528}{asstr}(a.tostring())
733 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aa93411d4b588b40e57a29dd47c1ab201}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!getsz@{getsz}}
\index{getsz@{getsz}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{getsz}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+getsz (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{addr}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aa93411d4b588b40e57a29dd47c1ab201}
\begin{DoxyVerb}Get zero-terminated string from given address. Will raise 
NotEnoughDataError exception if a hole is encountered before a 0.
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+gets().


\begin{DoxyCode}
742     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aa93411d4b588b40e57a29dd47c1ab201}{getsz}(self, addr):
743         \textcolor{stringliteral}{"""Get zero-terminated string from given address. Will raise }
744 \textcolor{stringliteral}{        NotEnoughDataError exception if a hole is encountered before a 0.}
745 \textcolor{stringliteral}{        """}
746         i = 0
747         \textcolor{keywordflow}{try}:
748             \textcolor{keywordflow}{while} \textcolor{keyword}{True}:
749                 \textcolor{keywordflow}{if} self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf}[addr + i] == 0:
750                     \textcolor{keywordflow}{break}
751                 i += 1
752         \textcolor{keywordflow}{except} KeyError:
753             \textcolor{keywordflow}{raise} \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1NotEnoughDataError}{NotEnoughDataError}(msg=(\textcolor{stringliteral}{'Bad access at 0x%X: '}
754                 \textcolor{stringliteral}{'not enough data to read zero-terminated string'}) % addr)
755         \textcolor{keywordflow}{return} self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a585027d569ec62b83f71a2a554f00045}{gets}(addr, i)
756 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_acd9716aa6677362786b1d8655b8707fb}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!loadbin@{loadbin}}
\index{loadbin@{loadbin}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{loadbin}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+loadbin (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{fobj, }
\item[{}]{offset = {\ttfamily 0}}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_acd9716aa6677362786b1d8655b8707fb}
\begin{DoxyVerb}Load bin file into internal buffer. Not needed if source set in
constructor. This will overwrite addresses without warning
if object was already initialized.

@param  fobj        file name or file-like object
@param  offset      starting address offset
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+asbytes, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+frombytes().



Referenced by software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+loadfile().


\begin{DoxyCode}
228     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_acd9716aa6677362786b1d8655b8707fb}{loadbin}(self, fobj, offset=0):
229         \textcolor{stringliteral}{"""Load bin file into internal buffer. Not needed if source set in}
230 \textcolor{stringliteral}{        constructor. This will overwrite addresses without warning}
231 \textcolor{stringliteral}{        if object was already initialized.}
232 \textcolor{stringliteral}{}
233 \textcolor{stringliteral}{        @param  fobj        file name or file-like object}
234 \textcolor{stringliteral}{        @param  offset      starting address offset}
235 \textcolor{stringliteral}{        """}
236         fread = getattr(fobj, \textcolor{stringliteral}{"read"}, \textcolor{keywordtype}{None})
237         \textcolor{keywordflow}{if} fread \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:
238             f = open(fobj, \textcolor{stringliteral}{"rb"})
239             fread = f.read
240             fclose = f.close
241         \textcolor{keywordflow}{else}:
242             fclose = \textcolor{keywordtype}{None}
243 
244         \textcolor{keywordflow}{try}:
245             self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aa262db6dc7ed1909cf4285783abd6d20}{frombytes}(array(\textcolor{stringliteral}{'B'}, \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a7f086f0677c4876409244a91e386b8cc}{asbytes}(fread())), offset=offset)
246         \textcolor{keywordflow}{finally}:
247             \textcolor{keywordflow}{if} fclose:
248                 fclose()
249 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ad59eb04b61c35a525596bbfbef87329f}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!loadfile@{loadfile}}
\index{loadfile@{loadfile}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{loadfile}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+loadfile (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{fobj, }
\item[{}]{format}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ad59eb04b61c35a525596bbfbef87329f}
\begin{DoxyVerb}Load data file into internal buffer. Preferred wrapper over
loadbin or loadhex.

@param  fobj        file name or file-like object
@param  format      file format ("hex" or "bin")
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+loadbin(), and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+loadhex().


\begin{DoxyCode}
250     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ad59eb04b61c35a525596bbfbef87329f}{loadfile}(self, fobj, format):
251         \textcolor{stringliteral}{"""Load data file into internal buffer. Preferred wrapper over}
252 \textcolor{stringliteral}{        loadbin or loadhex.}
253 \textcolor{stringliteral}{}
254 \textcolor{stringliteral}{        @param  fobj        file name or file-like object}
255 \textcolor{stringliteral}{        @param  format      file format ("hex" or "bin")}
256 \textcolor{stringliteral}{        """}
257         \textcolor{keywordflow}{if} format == \textcolor{stringliteral}{"hex"}:
258             self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a775e8d95913df4a5ad79a59e7155f605}{loadhex}(fobj)
259         \textcolor{keywordflow}{elif} format == \textcolor{stringliteral}{"bin"}:
260             self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_acd9716aa6677362786b1d8655b8707fb}{loadbin}(fobj)
261         \textcolor{keywordflow}{else}:
262             \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{'format should be either "hex" or "bin";'}
263                 \textcolor{stringliteral}{' got %r instead'} % format)
264 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a775e8d95913df4a5ad79a59e7155f605}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!loadhex@{loadhex}}
\index{loadhex@{loadhex}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{loadhex}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+loadhex (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{fobj}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a775e8d95913df4a5ad79a59e7155f605}
\begin{DoxyVerb}Load hex file into internal buffer. This is not necessary
if object was initialized with source set. This will overwrite
addresses if object was already initialized.

@param  fobj        file name or file-like object
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+decode\+\_\+record(), and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+offset.



Referenced by software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+loadfile().


\begin{DoxyCode}
200     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a775e8d95913df4a5ad79a59e7155f605}{loadhex}(self, fobj):
201         \textcolor{stringliteral}{"""Load hex file into internal buffer. This is not necessary}
202 \textcolor{stringliteral}{        if object was initialized with source set. This will overwrite}
203 \textcolor{stringliteral}{        addresses if object was already initialized.}
204 \textcolor{stringliteral}{}
205 \textcolor{stringliteral}{        @param  fobj        file name or file-like object}
206 \textcolor{stringliteral}{        """}
207         \textcolor{keywordflow}{if} getattr(fobj, \textcolor{stringliteral}{"read"}, \textcolor{keywordtype}{None}) \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:
208             fobj = open(fobj, \textcolor{stringliteral}{"}\textcolor{stringliteral}{r")}
209 \textcolor{stringliteral}{            fclose = fobj.close}
210 \textcolor{stringliteral}{        }\textcolor{keywordflow}{else}:
211             fclose = \textcolor{keywordtype}{None}
212 
213         self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ae76fa50a74ef63f6d385854c330203ef}{\_offset} = 0
214         line = 0
215 
216         \textcolor{keywordflow}{try}:
217             decode = self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a676ca5b64936c57e6688d0e6ecbc116d}{\_decode\_record}
218             \textcolor{keywordflow}{try}:
219                 \textcolor{keywordflow}{for} s \textcolor{keywordflow}{in} fobj:
220                     line += 1
221                     decode(s, line)
222             \textcolor{keywordflow}{except} \_EndOfFile:
223                 \textcolor{keywordflow}{pass}
224         \textcolor{keywordflow}{finally}:
225             \textcolor{keywordflow}{if} fclose:
226                 fclose()
227 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aee2c8b04d227d7fe36ffe916c7b85650}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!maxaddr@{maxaddr}}
\index{maxaddr@{maxaddr}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{maxaddr}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+maxaddr (
\begin{DoxyParamCaption}
\item[{}]{self}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aee2c8b04d227d7fe36ffe916c7b85650}
\begin{DoxyVerb}Get maximal address of HEX content.
@return         maximal address or None if no data
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+dict\+\_\+keys().



Referenced by software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+frombytes().


\begin{DoxyCode}
452     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aee2c8b04d227d7fe36ffe916c7b85650}{maxaddr}(self):
453         \textcolor{stringliteral}{'''Get maximal address of HEX content.}
454 \textcolor{stringliteral}{        @return         maximal address or None if no data}
455 \textcolor{stringliteral}{        '''}
456         aa = \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a675ad269e4a9a3ee5a5b4b413d0fb690}{dict\_keys}(self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf})
457         \textcolor{keywordflow}{if} aa == []:
458             \textcolor{keywordflow}{return} \textcolor{keywordtype}{None}
459         \textcolor{keywordflow}{else}:
460             \textcolor{keywordflow}{return} max(aa)
461 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a8f12aea49042cd61c56c2d650fab5fa2}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!merge@{merge}}
\index{merge@{merge}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{merge}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+merge (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{other, }
\item[{}]{overlap = {\ttfamily \textquotesingle{}error\textquotesingle{}}}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a8f12aea49042cd61c56c2d650fab5fa2}
\begin{DoxyVerb}Merge content of other IntelHex object into current object (self).
@param  other   other IntelHex object.
@param  overlap action on overlap of data or starting addr:
        - error: raising OverlapError;
        - ignore: ignore other data and keep current data
                  in overlapping region;
        - replace: replace data with other data
                  in overlapping region.

@raise  TypeError       if other is not instance of IntelHex
@raise  ValueError      if other is the same object as self 
                (it can't merge itself)
@raise  ValueError      if overlap argument has incorrect value
@raise  AddressOverlapError    on overlapped data
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+start\+\_\+addr.


\begin{DoxyCode}
811     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a8f12aea49042cd61c56c2d650fab5fa2}{merge}(self, other, overlap='error'):
812         \textcolor{stringliteral}{"""Merge content of other IntelHex object into current object (self).}
813 \textcolor{stringliteral}{        @param  other   other IntelHex object.}
814 \textcolor{stringliteral}{        @param  overlap action on overlap of data or starting addr:}
815 \textcolor{stringliteral}{                        - error: raising OverlapError;}
816 \textcolor{stringliteral}{                        - ignore: ignore other data and keep current data}
817 \textcolor{stringliteral}{                                  in overlapping region;}
818 \textcolor{stringliteral}{                        - replace: replace data with other data}
819 \textcolor{stringliteral}{                                  in overlapping region.}
820 \textcolor{stringliteral}{}
821 \textcolor{stringliteral}{        @raise  TypeError       if other is not instance of IntelHex}
822 \textcolor{stringliteral}{        @raise  ValueError      if other is the same object as self }
823 \textcolor{stringliteral}{                                (it can't merge itself)}
824 \textcolor{stringliteral}{        @raise  ValueError      if overlap argument has incorrect value}
825 \textcolor{stringliteral}{        @raise  AddressOverlapError    on overlapped data}
826 \textcolor{stringliteral}{        """}
827         \textcolor{comment}{# check args}
828         \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} isinstance(other, IntelHex):
829             \textcolor{keywordflow}{raise} TypeError(\textcolor{stringliteral}{'other should be IntelHex object'})
830         \textcolor{keywordflow}{if} other \textcolor{keywordflow}{is} self:
831             \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"Can't merge itself"})
832         \textcolor{keywordflow}{if} overlap \textcolor{keywordflow}{not} \textcolor{keywordflow}{in} (\textcolor{stringliteral}{'error'}, \textcolor{stringliteral}{'ignore'}, \textcolor{stringliteral}{'replace'}):
833             \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{"overlap argument should be either "}
834                 \textcolor{stringliteral}{"'error', 'ignore' or 'replace'"})
835         \textcolor{comment}{# merge data}
836         this\_buf = self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf}
837         other\_buf = other.\_buf
838         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} other\_buf:
839             \textcolor{keywordflow}{if} i \textcolor{keywordflow}{in} this\_buf:
840                 \textcolor{keywordflow}{if} overlap == \textcolor{stringliteral}{'error'}:
841                     \textcolor{keywordflow}{raise} \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1AddressOverlapError}{AddressOverlapError}(
842                         \textcolor{stringliteral}{'Data overlapped at address 0x%X'} % i)
843                 \textcolor{keywordflow}{elif} overlap == \textcolor{stringliteral}{'ignore'}:
844                     \textcolor{keywordflow}{continue}
845             this\_buf[i] = other\_buf[i]
846         \textcolor{comment}{# merge start\_addr}
847         \textcolor{keywordflow}{if} self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr} != other.start\_addr:
848             \textcolor{keywordflow}{if} self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr} \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:  \textcolor{comment}{# set start addr from other}
849                 self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr} = other.start\_addr
850             \textcolor{keywordflow}{elif} other.start\_addr \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:  \textcolor{comment}{# keep existing start addr}
851                 \textcolor{keywordflow}{pass}
852             \textcolor{keywordflow}{else}:  \textcolor{comment}{# conflict}
853                 \textcolor{keywordflow}{if} overlap == \textcolor{stringliteral}{'error'}:
854                     \textcolor{keywordflow}{raise} \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1AddressOverlapError}{AddressOverlapError}(
855                         \textcolor{stringliteral}{'Starting addresses are different'})
856                 \textcolor{keywordflow}{elif} overlap == \textcolor{stringliteral}{'replace'}:
857                     self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr} = other.start\_addr
858 \textcolor{comment}{# /IntelHex}
859 
860 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ace69ca817be9cb8f87c5f18751f7a519}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!minaddr@{minaddr}}
\index{minaddr@{minaddr}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{minaddr}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+minaddr (
\begin{DoxyParamCaption}
\item[{}]{self}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ace69ca817be9cb8f87c5f18751f7a519}
\begin{DoxyVerb}Get minimal address of HEX content.
@return         minimal address or None if no data
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+dict\+\_\+keys().



Referenced by software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+frombytes().


\begin{DoxyCode}
442     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_ace69ca817be9cb8f87c5f18751f7a519}{minaddr}(self):
443         \textcolor{stringliteral}{'''Get minimal address of HEX content.}
444 \textcolor{stringliteral}{        @return         minimal address or None if no data}
445 \textcolor{stringliteral}{        '''}
446         aa = \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a675ad269e4a9a3ee5a5b4b413d0fb690}{dict\_keys}(self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf})
447         \textcolor{keywordflow}{if} aa == []:
448             \textcolor{keywordflow}{return} \textcolor{keywordtype}{None}
449         \textcolor{keywordflow}{else}:
450             \textcolor{keywordflow}{return} min(aa)
451 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_af871cf5e14945bd217996c1cae0c2fa3}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!puts@{puts}}
\index{puts@{puts}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{puts}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+puts (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{addr, }
\item[{}]{s}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_af871cf5e14945bd217996c1cae0c2fa3}
\begin{DoxyVerb}Put string of bytes at given address. Will overwrite any previous
entries.
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+asbytes, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+range\+\_\+g.



Referenced by software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+putsz().


\begin{DoxyCode}
734     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_af871cf5e14945bd217996c1cae0c2fa3}{puts}(self, addr, s):
735         \textcolor{stringliteral}{"""Put string of bytes at given address. Will overwrite any previous}
736 \textcolor{stringliteral}{        entries.}
737 \textcolor{stringliteral}{        """}
738         a = array(\textcolor{stringliteral}{'B'}, \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a7f086f0677c4876409244a91e386b8cc}{asbytes}(s))
739         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_abac275d54b0c0dc47a6ef2f7c4f7bcdf}{range\_g}(len(a)):
740             self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf}[addr + i] = a[i]
741 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a533c4b8136caaf0fdfb0f9588cbf09c2}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!putsz@{putsz}}
\index{putsz@{putsz}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{putsz}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+putsz (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{addr, }
\item[{}]{s}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a533c4b8136caaf0fdfb0f9588cbf09c2}
\begin{DoxyVerb}Put string in object at addr and append terminating zero at end.\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+puts().


\begin{DoxyCode}
757     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a533c4b8136caaf0fdfb0f9588cbf09c2}{putsz}(self, addr, s):
758         \textcolor{stringliteral}{"""Put string in object at addr and append terminating zero at end."""}
759         self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_af871cf5e14945bd217996c1cae0c2fa3}{puts}(addr, s)
760         self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf}[addr + len(s)] = 0
761 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a328f8941824c4b535fb8bafbc1dd9add}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!tobinarray@{tobinarray}}
\index{tobinarray@{tobinarray}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{tobinarray}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+tobinarray (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{start = {\ttfamily None}, }
\item[{}]{end = {\ttfamily None}, }
\item[{}]{pad = {\ttfamily {\bf \+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D}}, }
\item[{}]{size = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a328f8941824c4b535fb8bafbc1dd9add}
\begin{DoxyVerb}Convert this object to binary form as array. If start and end 
unspecified, they will be inferred from the data.
@param  start   start address of output bytes.
@param  end     end address of output bytes (inclusive).
@param  pad     [DEPRECATED PARAMETER, please use self.padding instead]
        fill empty spaces with this value
        (if pad is None then this method uses self.padding).
@param  size    size of the block, used with start or end parameter.
@return         array of unsigned char data.
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+get\+\_\+start\+\_\+end(), software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+tobinarray\+\_\+really(), software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+padding, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+range\+\_\+g.


\begin{DoxyCode}
327     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a328f8941824c4b535fb8bafbc1dd9add}{tobinarray}(self, start=None, end=None, pad=\_DEPRECATED, size=None):
328         \textcolor{stringliteral}{''' Convert this object to binary form as array. If start and end }
329 \textcolor{stringliteral}{        unspecified, they will be inferred from the data.}
330 \textcolor{stringliteral}{        @param  start   start address of output bytes.}
331 \textcolor{stringliteral}{        @param  end     end address of output bytes (inclusive).}
332 \textcolor{stringliteral}{        @param  pad     [DEPRECATED PARAMETER, please use self.padding instead]}
333 \textcolor{stringliteral}{                        fill empty spaces with this value}
334 \textcolor{stringliteral}{                        (if pad is None then this method uses self.padding).}
335 \textcolor{stringliteral}{        @param  size    size of the block, used with start or end parameter.}
336 \textcolor{stringliteral}{        @return         array of unsigned char data.}
337 \textcolor{stringliteral}{        '''}
338         \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} isinstance(pad, \_DeprecatedParam):
339             \textcolor{keywordflow}{print} (\textcolor{stringliteral}{"IntelHex.tobinarray: 'pad' parameter is deprecated."})
340             \textcolor{keywordflow}{if} pad \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
341                 \textcolor{keywordflow}{print} (\textcolor{stringliteral}{"Please, use IntelHex.padding attribute instead."})
342             \textcolor{keywordflow}{else}:
343                 \textcolor{keywordflow}{print} (\textcolor{stringliteral}{"Please, don't pass it explicitly."})
344                 \textcolor{keywordflow}{print} (\textcolor{stringliteral}{"Use syntax like this: ih.tobinarray(start=xxx, end=yyy, size=zzz)"})
345         \textcolor{keywordflow}{else}:
346             pad = \textcolor{keywordtype}{None}
347         \textcolor{keywordflow}{return} self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a080abef69e58593b69483649b1838a74}{\_tobinarray\_really}(start, end, pad, size)
348 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a1591d7944d6232ffbe20231e5b3547e0}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!tobinfile@{tobinfile}}
\index{tobinfile@{tobinfile}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{tobinfile}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+tobinfile (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{fobj, }
\item[{}]{start = {\ttfamily None}, }
\item[{}]{end = {\ttfamily None}, }
\item[{}]{pad = {\ttfamily {\bf \+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D}}, }
\item[{}]{size = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a1591d7944d6232ffbe20231e5b3547e0}
\begin{DoxyVerb}Convert to binary and write to file.

@param  fobj    file name or file object for writing output bytes.
@param  start   start address of output bytes.
@param  end     end address of output bytes (inclusive).
@param  pad     [DEPRECATED PARAMETER, please use self.padding instead]
        fill empty spaces with this value
        (if pad is None then this method uses self.padding).
@param  size    size of the block, used with start or end parameter.
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+tobinstr\+\_\+really().



Referenced by software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+tofile().


\begin{DoxyCode}
392     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a1591d7944d6232ffbe20231e5b3547e0}{tobinfile}(self, fobj, start=None, end=None, pad=\_DEPRECATED, size=None):
393         \textcolor{stringliteral}{'''Convert to binary and write to file.}
394 \textcolor{stringliteral}{}
395 \textcolor{stringliteral}{        @param  fobj    file name or file object for writing output bytes.}
396 \textcolor{stringliteral}{        @param  start   start address of output bytes.}
397 \textcolor{stringliteral}{        @param  end     end address of output bytes (inclusive).}
398 \textcolor{stringliteral}{        @param  pad     [DEPRECATED PARAMETER, please use self.padding instead]}
399 \textcolor{stringliteral}{                        fill empty spaces with this value}
400 \textcolor{stringliteral}{                        (if pad is None then this method uses self.padding).}
401 \textcolor{stringliteral}{        @param  size    size of the block, used with start or end parameter.}
402 \textcolor{stringliteral}{        '''}
403         \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} isinstance(pad, \_DeprecatedParam):
404             \textcolor{keywordflow}{print} (\textcolor{stringliteral}{"IntelHex.tobinfile: 'pad' parameter is deprecated."})
405             \textcolor{keywordflow}{if} pad \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
406                 \textcolor{keywordflow}{print} (\textcolor{stringliteral}{"Please, use IntelHex.padding attribute instead."})
407             \textcolor{keywordflow}{else}:
408                 \textcolor{keywordflow}{print} (\textcolor{stringliteral}{"Please, don't pass it explicitly."})
409                 \textcolor{keywordflow}{print} (\textcolor{stringliteral}{"Use syntax like this: ih.tobinfile(start=xxx, end=yyy, size=zzz)"})
410         \textcolor{keywordflow}{else}:
411             pad = \textcolor{keywordtype}{None}
412         \textcolor{keywordflow}{if} getattr(fobj, \textcolor{stringliteral}{"write"}, \textcolor{keywordtype}{None}) \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:
413             fobj = open(fobj, \textcolor{stringliteral}{"wb"})
414             close\_fd = \textcolor{keyword}{True}
415         \textcolor{keywordflow}{else}:
416             close\_fd = \textcolor{keyword}{False}
417 
418         fobj.write(self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a55a3436c4a45cc85f8c0d85add6f817a}{\_tobinstr\_really}(start, end, pad, size))
419 
420         \textcolor{keywordflow}{if} close\_fd:
421             fobj.close()
422 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a63beaff3fa8ff85530da070327451542}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!tobinstr@{tobinstr}}
\index{tobinstr@{tobinstr}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{tobinstr}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+tobinstr (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{start = {\ttfamily None}, }
\item[{}]{end = {\ttfamily None}, }
\item[{}]{pad = {\ttfamily {\bf \+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+E\+D}}, }
\item[{}]{size = {\ttfamily None}}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a63beaff3fa8ff85530da070327451542}
\begin{DoxyVerb}Convert to binary form and return as binary string.
@param  start   start address of output bytes.
@param  end     end address of output bytes (inclusive).
@param  pad     [DEPRECATED PARAMETER, please use self.padding instead]
        fill empty spaces with this value
        (if pad is None then this method uses self.padding).
@param  size    size of the block, used with start or end parameter.
@return         string of binary data.
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+tobinarray\+\_\+really(), software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+tobinstr\+\_\+really(), and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+asbytes.


\begin{DoxyCode}
368     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a63beaff3fa8ff85530da070327451542}{tobinstr}(self, start=None, end=None, pad=\_DEPRECATED, size=None):
369         \textcolor{stringliteral}{''' Convert to binary form and return as binary string.}
370 \textcolor{stringliteral}{        @param  start   start address of output bytes.}
371 \textcolor{stringliteral}{        @param  end     end address of output bytes (inclusive).}
372 \textcolor{stringliteral}{        @param  pad     [DEPRECATED PARAMETER, please use self.padding instead]}
373 \textcolor{stringliteral}{                        fill empty spaces with this value}
374 \textcolor{stringliteral}{                        (if pad is None then this method uses self.padding).}
375 \textcolor{stringliteral}{        @param  size    size of the block, used with start or end parameter.}
376 \textcolor{stringliteral}{        @return         string of binary data.}
377 \textcolor{stringliteral}{        '''}
378         \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} isinstance(pad, \_DeprecatedParam):
379             \textcolor{keywordflow}{print} (\textcolor{stringliteral}{"IntelHex.tobinstr: 'pad' parameter is deprecated."})
380             \textcolor{keywordflow}{if} pad \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} \textcolor{keywordtype}{None}:
381                 \textcolor{keywordflow}{print} (\textcolor{stringliteral}{"Please, use IntelHex.padding attribute instead."})
382             \textcolor{keywordflow}{else}:
383                 \textcolor{keywordflow}{print} (\textcolor{stringliteral}{"Please, don't pass it explicitly."})
384                 \textcolor{keywordflow}{print} (\textcolor{stringliteral}{"Use syntax like this: ih.tobinstr(start=xxx, end=yyy, size=zzz)"})
385         \textcolor{keywordflow}{else}:
386             pad = \textcolor{keywordtype}{None}
387         \textcolor{keywordflow}{return} self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a55a3436c4a45cc85f8c0d85add6f817a}{\_tobinstr\_really}(start, end, pad, size)
388 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a7a570a4d3b81de987e2feb5fd1246ed3}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!todict@{todict}}
\index{todict@{todict}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{todict}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+todict (
\begin{DoxyParamCaption}
\item[{}]{self}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a7a570a4d3b81de987e2feb5fd1246ed3}
\begin{DoxyVerb}Convert to python dictionary.

@return         dict suitable for initializing another IntelHex object.
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+start\+\_\+addr.


\begin{DoxyCode}
423     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a7a570a4d3b81de987e2feb5fd1246ed3}{todict}(self):
424         \textcolor{stringliteral}{'''Convert to python dictionary.}
425 \textcolor{stringliteral}{}
426 \textcolor{stringliteral}{        @return         dict suitable for initializing another IntelHex object.}
427 \textcolor{stringliteral}{        '''}
428         r = \{\}
429         r.update(self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf})
430         \textcolor{keywordflow}{if} self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr}:
431             r[\textcolor{stringliteral}{'start\_addr'}] = self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr}
432         \textcolor{keywordflow}{return} r
433 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a2781d7631635f5ea07af10cd11f25908}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!tofile@{tofile}}
\index{tofile@{tofile}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{tofile}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+tofile (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{fobj, }
\item[{}]{format}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a2781d7631635f5ea07af10cd11f25908}
\begin{DoxyVerb}Write data to hex or bin file. Preferred method over tobin or tohex.

@param  fobj        file name or file-like object
@param  format      file format ("hex" or "bin")
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+tobinfile(), and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+write\+\_\+hex\+\_\+file().


\begin{DoxyCode}
708     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a2781d7631635f5ea07af10cd11f25908}{tofile}(self, fobj, format):
709         \textcolor{stringliteral}{"""Write data to hex or bin file. Preferred method over tobin or tohex.}
710 \textcolor{stringliteral}{}
711 \textcolor{stringliteral}{        @param  fobj        file name or file-like object}
712 \textcolor{stringliteral}{        @param  format      file format ("hex" or "bin")}
713 \textcolor{stringliteral}{        """}
714         \textcolor{keywordflow}{if} format == \textcolor{stringliteral}{'hex'}:
715             self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a8f58a0cbc330f6c0304a291b7ffad1aa}{write\_hex\_file}(fobj)
716         \textcolor{keywordflow}{elif} format == \textcolor{stringliteral}{'bin'}:
717             self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a1591d7944d6232ffbe20231e5b3547e0}{tobinfile}(fobj)
718         \textcolor{keywordflow}{else}:
719             \textcolor{keywordflow}{raise} ValueError(\textcolor{stringliteral}{'format should be either "hex" or "bin";'}
720                 \textcolor{stringliteral}{' got %r instead'} % format)
721 
\end{DoxyCode}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a8f58a0cbc330f6c0304a291b7ffad1aa}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!write\+\_\+hex\+\_\+file@{write\+\_\+hex\+\_\+file}}
\index{write\+\_\+hex\+\_\+file@{write\+\_\+hex\+\_\+file}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{write\+\_\+hex\+\_\+file}]{\setlength{\rightskip}{0pt plus 5cm}def software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+write\+\_\+hex\+\_\+file (
\begin{DoxyParamCaption}
\item[{}]{self, }
\item[{}]{f, }
\item[{}]{write\+\_\+start\+\_\+addr = {\ttfamily True}}
\end{DoxyParamCaption}
)}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a8f58a0cbc330f6c0304a291b7ffad1aa}
\begin{DoxyVerb}Write data to file f in HEX format.

@param  f                   filename or file-like object for writing
@param  write_start_addr    enable or disable writing start address
                    record to file (enabled by default).
                    If there is no start address in obj, nothing
                    will be written regardless of this setting.
\end{DoxyVerb}
 

References software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+buf, software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+asbytes, software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+asstr, software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+dict\+\_\+keys(), software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+range\+\_\+g, software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+range\+\_\+l, and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+start\+\_\+addr.



Referenced by software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+tofile().


\begin{DoxyCode}
549     \textcolor{keyword}{def }\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a8f58a0cbc330f6c0304a291b7ffad1aa}{write\_hex\_file}(self, f, write\_start\_addr=True):
550         \textcolor{stringliteral}{"""Write data to file f in HEX format.}
551 \textcolor{stringliteral}{}
552 \textcolor{stringliteral}{        @param  f                   filename or file-like object for writing}
553 \textcolor{stringliteral}{        @param  write\_start\_addr    enable or disable writing start address}
554 \textcolor{stringliteral}{                                    record to file (enabled by default).}
555 \textcolor{stringliteral}{                                    If there is no start address in obj, nothing}
556 \textcolor{stringliteral}{                                    will be written regardless of this setting.}
557 \textcolor{stringliteral}{        """}
558         fwrite = getattr(f, \textcolor{stringliteral}{"write"}, \textcolor{keywordtype}{None})
559         \textcolor{keywordflow}{if} fwrite:
560             fobj = f
561             fclose = \textcolor{keywordtype}{None}
562         \textcolor{keywordflow}{else}:
563             fobj = open(f, \textcolor{stringliteral}{'w'})
564             fwrite = fobj.write
565             fclose = fobj.close
566 
567         \textcolor{comment}{# Translation table for uppercasing hex ascii string.}
568         \textcolor{comment}{# timeit shows that using hexstr.translate(table)}
569         \textcolor{comment}{# is faster than hexstr.upper():}
570         \textcolor{comment}{# 0.452ms vs. 0.652ms (translate vs. upper)}
571         \textcolor{keywordflow}{if} sys.version\_info[0] >= 3:
572             \textcolor{comment}{# Python 3}
573             table = bytes(\hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_ae461be5d25f46823cb710380e27eb1a1}{range\_l}(256)).upper()
574         \textcolor{keywordflow}{else}:
575             \textcolor{comment}{# Python 2}
576             table = \textcolor{stringliteral}{''}.join(chr(i).upper() \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_abac275d54b0c0dc47a6ef2f7c4f7bcdf}{range\_g}(256))
577 
578 
579 
580         \textcolor{comment}{# start address record if any}
581         \textcolor{keywordflow}{if} self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr} \textcolor{keywordflow}{and} write\_start\_addr:
582             keys = \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a675ad269e4a9a3ee5a5b4b413d0fb690}{dict\_keys}(self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr})
583             keys.sort()
584             bin = array(\textcolor{stringliteral}{'B'}, \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a7f086f0677c4876409244a91e386b8cc}{asbytes}(\textcolor{stringliteral}{'\(\backslash\)0'} * 9))
585             \textcolor{keywordflow}{if} keys == [\textcolor{stringliteral}{'CS'}, \textcolor{stringliteral}{'IP'}]:
586                 \textcolor{comment}{# Start Segment Address Record}
587                 bin[0] = 4  \textcolor{comment}{# reclen}
588                 bin[1] = 0  \textcolor{comment}{# offset msb}
589                 bin[2] = 0  \textcolor{comment}{# offset lsb}
590                 bin[3] = 3  \textcolor{comment}{# rectyp}
591                 cs = self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr}[\textcolor{stringliteral}{'CS'}]
592                 bin[4] = (cs >> 8) & 0x0FF
593                 bin[5] = cs & 0x0FF
594                 ip = self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr}[\textcolor{stringliteral}{'IP'}]
595                 bin[6] = (ip >> 8) & 0x0FF
596                 bin[7] = ip & 0x0FF
597                 bin[8] = (-sum(bin)) & 0x0FF  \textcolor{comment}{# chksum}
598                 fwrite(\textcolor{stringliteral}{':'} +
599                        \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a32eb6deeafe6dba1f76d94543cff7528}{asstr}(hexlify(bin.tostring()).translate(table)) +
600                        \textcolor{stringliteral}{'\(\backslash\)n'})
601             \textcolor{keywordflow}{elif} keys == [\textcolor{stringliteral}{'EIP'}]:
602                 \textcolor{comment}{# Start Linear Address Record}
603                 bin[0] = 4  \textcolor{comment}{# reclen}
604                 bin[1] = 0  \textcolor{comment}{# offset msb}
605                 bin[2] = 0  \textcolor{comment}{# offset lsb}
606                 bin[3] = 5  \textcolor{comment}{# rectyp}
607                 eip = self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr}[\textcolor{stringliteral}{'EIP'}]
608                 bin[4] = (eip >> 24) & 0x0FF
609                 bin[5] = (eip >> 16) & 0x0FF
610                 bin[6] = (eip >> 8) & 0x0FF
611                 bin[7] = eip & 0x0FF
612                 bin[8] = (-sum(bin)) & 0x0FF  \textcolor{comment}{# chksum}
613                 fwrite(\textcolor{stringliteral}{':'} +
614                        \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a32eb6deeafe6dba1f76d94543cff7528}{asstr}(hexlify(bin.tostring()).translate(table)) +
615                        \textcolor{stringliteral}{'\(\backslash\)n'})
616             \textcolor{keywordflow}{else}:
617                 \textcolor{keywordflow}{if} fclose:
618                     fclose()
619                 \textcolor{keywordflow}{raise} \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1InvalidStartAddressValueError}{InvalidStartAddressValueError}(start\_addr=self.
      \hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{start\_addr})
620 
621         \textcolor{comment}{# data}
622         addresses = \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a675ad269e4a9a3ee5a5b4b413d0fb690}{dict\_keys}(self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf})
623         addresses.sort()
624         addr\_len = len(addresses)
625         \textcolor{keywordflow}{if} addr\_len:
626             minaddr = addresses[0]
627             maxaddr = addresses[-1]
628 
629             \textcolor{keywordflow}{if} maxaddr > 65535:
630                 need\_offset\_record = \textcolor{keyword}{True}
631             \textcolor{keywordflow}{else}:
632                 need\_offset\_record = \textcolor{keyword}{False}
633             high\_ofs = 0
634 
635             cur\_addr = minaddr
636             cur\_ix = 0
637 
638             \textcolor{keywordflow}{while} cur\_addr <= maxaddr:
639                 \textcolor{keywordflow}{if} need\_offset\_record:
640                     bin = array(\textcolor{stringliteral}{'B'}, \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a7f086f0677c4876409244a91e386b8cc}{asbytes}(\textcolor{stringliteral}{'\(\backslash\)0'} * 7))
641                     bin[0] = 2  \textcolor{comment}{# reclen}
642                     bin[1] = 0  \textcolor{comment}{# offset msb}
643                     bin[2] = 0  \textcolor{comment}{# offset lsb}
644                     bin[3] = 4  \textcolor{comment}{# rectyp}
645                     high\_ofs = int(cur\_addr >> 16)
646                     b = divmod(high\_ofs, 256)
647                     bin[4] = b[0]  \textcolor{comment}{# msb of high\_ofs}
648                     bin[5] = b[1]  \textcolor{comment}{# lsb of high\_ofs}
649                     bin[6] = (-sum(bin)) & 0x0FF  \textcolor{comment}{# chksum}
650                     fwrite(\textcolor{stringliteral}{':'} +
651                            \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a32eb6deeafe6dba1f76d94543cff7528}{asstr}(hexlify(bin.tostring()).translate(table)) +
652                            \textcolor{stringliteral}{'\(\backslash\)n'})
653 
654                 \textcolor{keywordflow}{while} \textcolor{keyword}{True}:
655                     \textcolor{comment}{# produce one record}
656                     low\_addr = cur\_addr & 0x0FFFF
657                     \textcolor{comment}{# chain\_len off by 1}
658                     chain\_len = min(15, 65535 - low\_addr, maxaddr - cur\_addr)
659 
660                     \textcolor{comment}{# search continuous chain}
661                     stop\_addr = cur\_addr + chain\_len
662                     \textcolor{keywordflow}{if} chain\_len:
663                         ix = bisect\_right(addresses, stop\_addr,
664                                           cur\_ix,
665                                           min(cur\_ix + chain\_len + 1, addr\_len))
666                         chain\_len = ix - cur\_ix  \textcolor{comment}{# real chain\_len}
667                         \textcolor{comment}{# there could be small holes in the chain}
668                         \textcolor{comment}{# but we will catch them by try-except later}
669                         \textcolor{comment}{# so for big continuous files we will work}
670                         \textcolor{comment}{# at maximum possible speed}
671                     \textcolor{keywordflow}{else}:
672                         chain\_len = 1  \textcolor{comment}{# real chain\_len}
673 
674                     bin = array(\textcolor{stringliteral}{'B'}, \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a7f086f0677c4876409244a91e386b8cc}{asbytes}(\textcolor{stringliteral}{'\(\backslash\)0'} * (5 + chain\_len)))
675                     b = divmod(low\_addr, 256)
676                     bin[1] = b[0]  \textcolor{comment}{# msb of low\_addr}
677                     bin[2] = b[1]  \textcolor{comment}{# lsb of low\_addr}
678                     bin[3] = 0  \textcolor{comment}{# rectype}
679                     \textcolor{keywordflow}{try}:  \textcolor{comment}{# if there is small holes we'll catch them}
680                         \textcolor{keywordflow}{for} i \textcolor{keywordflow}{in} \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_abac275d54b0c0dc47a6ef2f7c4f7bcdf}{range\_g}(chain\_len):
681                             bin[4 + i] = self.\hyperlink{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a9acc18c6165db7a6540c07688a8e09ac}{\_buf}[cur\_addr + i]
682                     \textcolor{keywordflow}{except} KeyError:
683                         \textcolor{comment}{# we catch a hole so we should shrink the chain}
684                         chain\_len = i
685                         bin = bin[:5 + i]
686                     bin[0] = chain\_len
687                     bin[4 + chain\_len] = (-sum(bin)) & 0x0FF  \textcolor{comment}{# chksum}
688                     fwrite(\textcolor{stringliteral}{':'} +
689                            \hyperlink{namespacesoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_a32eb6deeafe6dba1f76d94543cff7528}{asstr}(hexlify(bin.tostring()).translate(table)) +
690                            \textcolor{stringliteral}{'\(\backslash\)n'})
691 
692                     \textcolor{comment}{# adjust cur\_addr/cur\_ix}
693                     cur\_ix += chain\_len
694                     \textcolor{keywordflow}{if} cur\_ix < addr\_len:
695                         cur\_addr = addresses[cur\_ix]
696                     \textcolor{keywordflow}{else}:
697                         cur\_addr = maxaddr + 1
698                         \textcolor{keywordflow}{break}
699                     high\_addr = int(cur\_addr >> 16)
700                     \textcolor{keywordflow}{if} high\_addr > high\_ofs:
701                         \textcolor{keywordflow}{break}
702 
703         \textcolor{comment}{# end-of-file record}
704         fwrite(\textcolor{stringliteral}{":00000001FF\(\backslash\)n"})
705         \textcolor{keywordflow}{if} fclose:
706             fclose()
707 
\end{DoxyCode}


\subsection{Member Data Documentation}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aedb3e9ce405494ffb08bfd4051c9bcc7}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!fromfile@{fromfile}}
\index{fromfile@{fromfile}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{fromfile}]{\setlength{\rightskip}{0pt plus 5cm}software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+fromfile = {\bf loadfile}\hspace{0.3cm}{\ttfamily [static]}}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_aedb3e9ce405494ffb08bfd4051c9bcc7}
\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_af1b0c8c73d204cd8677cf6840511d3b0}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!padding@{padding}}
\index{padding@{padding}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{padding}]{\setlength{\rightskip}{0pt plus 5cm}software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+padding}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_af1b0c8c73d204cd8677cf6840511d3b0}


Referenced by software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+\_\+\+\_\+getitem\+\_\+\+\_\+(), software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex16bit.\+\_\+\+\_\+getitem\+\_\+\+\_\+(), and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+tobinarray().

\hypertarget{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}{}\index{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}!start\+\_\+addr@{start\+\_\+addr}}
\index{start\+\_\+addr@{start\+\_\+addr}!software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex@{software\+::chipwhisperer\+::capture\+::utils\+::\+Intel\+Hex\+::\+Intel\+Hex}}
\subsubsection[{start\+\_\+addr}]{\setlength{\rightskip}{0pt plus 5cm}software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+start\+\_\+addr}\label{classsoftware_1_1chipwhisperer_1_1capture_1_1utils_1_1IntelHex_1_1IntelHex_a5da95579a9d232f27b10682ef2422316}


Referenced by software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+dump(), software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+fromdict(), software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+merge(), software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+todict(), and software.\+chipwhisperer.\+capture.\+utils.\+Intel\+Hex.\+Intel\+Hex.\+write\+\_\+hex\+\_\+file().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{IntelHex_8py}{Intel\+Hex.\+py}\end{DoxyCompactItemize}
